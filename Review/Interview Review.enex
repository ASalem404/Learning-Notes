<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export4.dtd">
<en-export export-date="20231110T133025Z" application="Evernote" version="10.58.8">
  <note>
    <title>Interview Review</title>
    <created>20230806T000133Z</created>
    <updated>20230810T010829Z</updated>
    <note-attributes>
      <author>Ahmed Salem</author>
    </note-attributes>
    <content>
      <![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note><div><br/></div><hr/><div>Different architectures</div><div>web hooks</div><hr/><h3>Stack vs Heap</h3><ul><li><div>Stack is a segment of memory where data is added and/or removed in a last-in-first-out (LIFO) manner.</div></li><li><div>The memory size for the stack segment is predetermined by the operating system before compiling programs.</div></li><li><div>Stack is faster than the heap but limited in size.</div></li><li><div>Each thread will get its own stack.</div></li></ul><div style="padding-left:40px;">Stack stores:</div><ul style="--en-todo:true;"><ul><li><div>Local variables</div></li><li><div>Methods in execution</div></li></ul></ul><div style="padding-left:40px;">Heap stores:    </div><ul style="--en-todo:true;"><ul><li><div>Global and static variables</div></li><li><div>Variables which anonymous functions use</div></li><li><div>The results of async functions</div></li></ul></ul><div><a href="https://nickolasteixeira.medium.com/stack-vs-heap-whats-the-difference-and-why-should-i-care-5abc78da1a88" rev="en_rl_none">Stack vs Heap. What’s the difference and why should I care?</a></div><hr/><h3>Compile-time vs Run-time</h3><ul><li><div>Compile Time: The phase when the code is transformed into machine code or bytecode by the compiler. Syntax and semantic checks are performed, and compile-time errors are detected at this stage.</div></li><li><div>Runtime: The phase when the compiled or interpreted program is executed. The program performs its tasks, and any errors or issues that occur during execution are called runtime errors.</div></li></ul><hr/><h3>Inline Function</h3><div style="padding-left:40px;">An inline function is a concept in programming, particularly in languages like C++ and C, that suggests to the compiler that a certain function's code should be inserted directly at the point where the function is called, rather than performing a typical function call. This is done to improve performance by reducing the overhead of function calls.</div><div style="padding-left:40px;"><br/></div><div style="padding-left:40px;">When a function is called, there is a certain amount of overhead involved in terms of pushing arguments onto the stack, creating a stack frame, and jumping to the function's code. For small and simple functions, this overhead can be significant compared to the actual work done by the function. Inlining helps avoid this overhead by inserting the function's code directly where it's called.</div><div style="padding-left:40px;"><br/></div><div style="--en-codeblock:true; --en-lineWrapping:false;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>inline int Add(int a, int b) {</div><div>    return a + b;</div><div>}</div><div></div><div>int main() {</div><div>    int result = Add(5, 3); // The Add function's code is inserted here</div><div>    return 0;</div><div>}</div></div><div><br/></div><hr/><h3>Friend Function</h3><ol><li><div>Access to Private Members: Friend functions can access private and protected members of a class, as if they were part of the class itself.</div></li><li><div>Not a Member Function: Friend functions are not actually member functions of the class they are friends with. They are defined outside the class, but they are granted special access.</div></li><li><div>Declaration and Definition: Friend functions must be declared inside the class that grants friendship and defined outside the class.</div></li><li><div>Keyword: The friend keyword is used to declare a function as a friend function within a class.</div></li><li><div>No Inheritance: Friendship is not inherited. A friend function of a class does not have access to the private members of derived classes.</div></li><li><div>No Implicit 'this': Friend functions do not have access to the this pointer, as they are not member functions. Instead, they receive objects as explicit parameters.</div></li><li><div>Scope: Friend functions are not bound to the scope of the class. They can be defined anywhere in the same namespace.</div></li><li><div>Purpose: Friend functions are useful for providing specific external functions access to private members, without exposing those members publicly.</div></li></ol><div><br/></div><div style="--en-codeblock:true; --en-lineWrapping:false;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>class MyClass {</div><div>private:</div><div>    int privateData;</div><div></div><div>public:</div><div>    MyClass(int value) : privateData(value) {}</div><div></div><div>    // Declare the friend function</div><div>    friend void FriendFunction(const MyClass&amp; obj);</div><div>};</div><div></div><div>// Define the friend function</div><div>void FriendFunction(const MyClass&amp; obj) {</div><div>    std::cout &lt;&lt; "Friend function can access private data: " &lt;&lt; obj.privateData &lt;&lt; std::endl;</div><div>}</div><div></div><div>int main() {</div><div>    MyClass obj(42);</div><div>    FriendFunction(obj); // Call the friend function</div><div>    return 0;</div><div>}</div></div><div><br/></div><hr/><h3>Operator Overloading</h3><div style="padding-left:40px;">In languages like C++ and C#, operator overloading provides a way to make your classes more intuitive and expressive. Instead of relying solely on functions with names like add(), subtract(), and equals(), you can use familiar operators to perform those actions on your custom objects.</div><div style="--en-codeblock:true; --en-lineWrapping:false;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>int main() {</div><div>    Point p1(1.0, 2.0);</div><div>    Point p2(3.0, 4.0);</div><div>    </div><div>    Point result = p1 + p2; // Calls the overloaded + operator</div><div>    </div><div>    return 0;</div><div>}</div></div><div><br/></div><hr/><h3>SDLC</h3><div><br/></div><div>Waterfall Model:</div><ul><li><div>Linear and sequential SDLC approach.</div></li><li><div>Phases: Requirements, Design, Implementation, Testing, Deployment, Maintenance.</div></li><li><div>Clear documentation at each phase.</div></li><li><div>Well-suited for stable and fixed requirements.</div></li><li><div>Limited flexibility for changes after phases.</div></li><li><div>Project delays if errors found later.</div></li></ul><div><br/></div><div>Agile Model:</div><ul><li><div>Iterative and incremental approach.</div></li><li><div>Emphasizes collaboration, customer feedback, working software, and adapting to change.</div></li><li><div>Principles: Individuals over processes, working software over documentation, customer collaboration, responding to change.</div></li><li><div>Methodologies: Scrum, Kanban, XP.</div></li><li><div>Flexibility for changing requirements.</div></li><li><div>Early and frequent delivery of functional software.</div></li><li><div>Requires active customer involvement.</div></li><li><div>May lack comprehensive documentation.</div></li></ul><div><br/></div><hr/><h3>Why do we need OOP?</h3><div style="padding-left:40px;">OOP helps us think in terms of real-world objects.</div><div style="padding-left:40px;">For example, a patient is an object and has properties like name, age, and the doctor that will be treating them.</div><hr/><h3>Constructor and Destructor</h3><div style="padding-left:40px;">The constructor is a special member function that is called automatically when an object is created. It initializes the object's data members and sets its initial state.</div><div style="padding-left:40px;">The destructor is another special member function that is called automatically when an object goes out of scope or is explicitly deleted. It is responsible for cleaning up resources and performing necessary cleanup tasks.</div><div style="padding-left:40px;"><br/></div><div><br/></div><ul><li><div>Constructor Types in Java:</div></li><ol><li><div>Default Constructor:</div></li><ul><li><div>Automatically provided if no constructors are defined.</div></li><li><div>Initializes attributes with default values.</div></li><li><div>No arguments.</div></li></ul><li><div>Parameterized Constructor:</div></li><ul><li><div>Accepts arguments to initialize object attributes.</div></li><li><div>Enables custom object initialization.</div></li></ul><li><div>Copy Constructor:</div></li><ul><li><div>Creates a new object by copying attributes from another object.</div></li><li><div>Can take an object of the same class or alternative parameters.</div></li></ul><li><div>Chained Constructor:</div></li><ul><li><div>Allows one constructor to call another within the same class.</div></li><li><div>Reduces code duplication and provides multiple initialization paths.</div></li></ul><li><div>Private Constructor:</div></li><ul><li><div>Restricts direct object instantiation from outside the class.</div></li><li><div>Used in singleton patterns or utility classes.</div></li></ul></ol></ul><div><br/></div><hr/><h3>Ways to prevent a class from being instantiated:</h3><ol><li><div>Private Constructor:</div><div>Defining a private constructor prevents the class from being instantiated directly from outside the class. This is one of the most common methods used to achieve this.</div></li><li><div>Abstract Class:</div><div>Declaring a class as abstract means it can't be instantiated on its own. Subclasses that inherit from an abstract class can be instantiated, but the abstract class itself cannot.</div></li><li><div>Static Class (Utility Class):</div><div>By defining all constructors as private and providing only static methods, you prevent instances of the class from being created. This type of class is often used to group related utility methods.</div></li></ol><hr/><h3>Polymorphism</h3><ul><li><div>Static (compile-time)</div></li></ul><div style="padding-left:40px;">Static polymorphism is also known as compile-time polymorphism. It is achieved through function overloading and templates (in languages like C++). The method to be executed is determined at compile-time, based on the number or types of arguments passed to the function.</div><div style="padding-left:40px;">Function overloading: In static polymorphism, you can have multiple functions with the same name but different parameter lists. The correct function to be called is resolved at compile-time based on the number or types of arguments passed.</div><div style="padding-left:40px;">Early error detection: Any issues related to calling the wrong function or passing the wrong arguments are detected at compile-time.</div><div style="padding-left:40px;"><br/></div><ul><li><div>Dynamic (run-time)</div></li></ul><div style="padding-left:40px;">Dynamic polymorphism is also known as run-time polymorphism. It is achieved through inheritance and virtual functions. The method to be executed is determined at run-time, based on the actual type of the object being referred to, rather than the reference or pointer type.</div><div style="padding-left:40px;">In dynamic polymorphism, you have a base class and derived classes. The base class defines a virtual function, which can be overridden by the derived classes. When a method is called through a base class reference or pointer, the actual implementation of the function in the derived class is determined at run-time.</div><div style="padding-left:40px;">In OOP, a virtual method is a function or method that is declared in a base class and can be overridden by derived classes. When a method is declared as "virtual," it allows the derived classes to provide their own implementation of the method, instead of using the implementation provided in the base class.</div><div style="--en-codeblock:true; --en-lineWrapping:false;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>// Static Polymorphism.</div><div><br/></div><div>public class Calculator {</div><div>    // Method to add two integers</div><div>    public int add(int a, int b) {</div><div>        return a + b;</div><div>    }</div><div>    // Method to add three integers</div><div>    public int add(int a, int b, int c) {</div><div>        return a + b + c;</div><div>    }</div><div>    // Method to add two floating-point numbers</div><div>    public double add(double a, double b) {</div><div>        return a + b;</div><div>    }</div><div>    public static void main(String[] args) {</div><div>        Calculator calculator = new Calculator();</div><div>        int result1 = calculator.add(5, 10);</div><div>        int result2 = calculator.add(2, 3, 5);</div><div>        double result3 = calculator.add(3.14, 2.71);</div><div>        System.out.println("Result 1: " + result1); // Output: Result 1: 15</div><div>        System.out.println("Result 2: " + result2); // Output: Result 2: 10</div><div>        System.out.println("Result 3: " + result3); // Output: Result 3: 5.85</div><div>    }</div><div>}</div></div><div><br/></div><div style="--en-codeblock:true; --en-lineWrapping:false;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>// Dynamic Polymorphism.</div><div><br/></div><div>class Shape {</div><div>    public void draw() {</div><div>        System.out.println("Drawing a Shape.");</div><div>    }</div><div>}</div><div>class Circle extends Shape {</div><div>    @Override</div><div>    public void draw() {</div><div>        System.out.println("Drawing a Circle.");</div><div>    }</div><div>}</div><div>class Rectangle extends Shape {</div><div>    @Override</div><div>    public void draw() {</div><div>        System.out.println("Drawing a Rectangle.");</div><div>    }</div><div>}</div><div>public class DrawingApp {</div><div>    public static void main(String[] args) {</div><div>        Shape shape1 = new Circle();</div><div>        Shape shape2 = new Rectangle();</div><div>        shape1.draw(); // Output: Drawing a Circle.</div><div>        shape2.draw(); // Output: Drawing a Rectangle.</div><div>    }</div><div>}</div></div><div><br/></div><hr/><h3>Inheritance </h3><ol><li><div>Single Inheritance:</div></li><ul><li><div>Class inherit from another class</div></li></ul><li><div>Multiple Inheritance </div></li><ul><li><div>Class inherit from multiple classes</div></li></ul><li><div>Multilevel Inheritance:</div></li><ul><li><div>Involves a chain of classes where each derived class becomes the base class for the next one.</div></li><li><div>Creates a hierarchical structure where each level inherits attributes and behaviors from its ancestor.</div></li><li><div>Offers a clear parent-child relationship and allows gradual specialization.</div></li><li><div>Example: Animal -> Mammal -> Human.</div></li></ul></ol><div style="padding-left:160px;">     Grand-Fa -> Father -> Son</div><ol start="4"><li><div>Hierarchical Inheritance:</div></li><ul><li><div>Involves multiple classes inheriting from a single base class.</div></li><li><div>Creates a tree-like structure where multiple derived classes branch out from a single root class.</div></li><li><div>Each derived class may add specific attributes and behaviors to the common base class.</div></li><li><div>Offers a way to group similar classes under a common parent.</div></li><li><div>Example: Shape -> Circle, Rectangle.</div></li></ul><li><div>Hybrid Inheritance:</div></li><ul><li><div>Combines multiple inheritance and multilevel inheritance.</div></li><li><div>Involves inheriting from multiple classes while also forming a hierarchy of inheritance.</div></li><li><div>Can lead to complex relationships and potential ambiguities.</div></li><li><div>Requires careful design to avoid issues like the "diamond problem."</div></li><li><div>Example: Fish (extends Animal, implements Swimmer) and Human (implements Swimmer).</div></li></ul></ol><hr/><h3>Association</h3><div style="padding-left:40px;">Association represents a relationship between two or more classes where objects of one class are connected to objects of another class. It's a general term that can cover various types of relationships, including one-to-one, one-to-many, and many-to-many.</div><div style="padding-left:40px;"><br/></div><div style="padding-left:40px;">Types Of Association:</div><ul style="--en-todo:true;"><ul><li><div>Aggregation</div></li></ul></ul><div style="padding-left:120px;">Aggregation is a weaker form of association where a class (the whole) is associated with other classes (the parts), but the parts can exist independently. The whole may or may not own the parts, and their lifecycles are not necessarily tied together.</div><div style="padding-left:120px;"><br/></div><div style="--en-codeblock:true; --en-lineWrapping:false;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>class Department {</div><div>    private String name;</div><div>    // Other attributes and methods...</div><div>}</div><div>class Employee {</div><div>    private String name;</div><div>    private Department department;</div><div>    public Employee(String name, Department department) {</div><div>        this.name = name;</div><div>        this.department = department;</div><div>    }</div><div>    // Other attributes and methods...</div><div>}</div></div><div>         </div><ul style="--en-todo:true;"><ul><li><div>Composition</div></li></ul></ul><div style="padding-left:120px;">Composition is a strong form of association where a class (the whole) contains or is composed of other classes (the parts). The parts cannot exist independently of the whole, and when the whole is destroyed, its parts are also destroyed.</div><div style="padding-left:120px;"><br/></div><div style="--en-codeblock:true; --en-lineWrapping:false;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>class Engine {</div><div>    // Engine attributes and methods...</div><div>}</div><div>class Car {</div><div>    private Engine engine;</div><div>    public Car() {</div><div>        this.engine = new Engine();</div><div>    }</div><div>    // Car attributes and methods...</div><div>}</div></div><div><br/></div><hr/><h3>REST API</h3><div style="padding-left:40px;"><br/></div><ol><li><div>Statelessness:</div></li><ul><li><div>Each request is self-contained.</div></li><li><div>No client context is stored on the server.</div></li><li><div>Example: Creating a new blog post by providing all details in the request.</div></li></ul><li><div>Client-Server Architecture:</div></li><ul><li><div>Client handles user interface.</div></li><li><div>Server handles data storage and processing.</div></li><li><div>Example: Web browser displays blog posts, server manages data.</div></li></ul><li><div>Uniform Interface:</div></li><ul><li><div>HTTP methods and URLs have specific meanings.</div></li><li><div>Examples:</div></li><ul><li><div>GET /api/posts: Retrieve all blog posts.</div></li><li><div>POST /api/posts: Create a new blog post.</div></li><li><div>PUT /api/posts/{post_id}: Update a blog post.</div></li><li><div>DELETE /api/posts/{post_id}: Delete a blog post.</div></li></ul></ul><li><div>Resource-Based:</div></li><ul><li><div>Resources are entities like blog posts.</div></li><li><div>Identified by URLs.</div></li><li><div>Example: URL /api/posts/123 points to blog post with ID 123.</div></li></ul><li><div>Cacheability:</div></li><ul><li><div>Responses can be cached for performance.</div></li><li><div>Reduces repeated requests for unchanged data.</div></li><li><div>Example: Cache list of blog posts for a period.</div></li></ul><li><div>Layered System:</div></li><ul><li><div>Multiple layers with specific roles.</div></li><li><div>Enhances scalability and flexibility.</div></li><li><div>Example: Authentication, business logic, and database layers.</div></li></ul><li><div>Code on Demand (Optional):</div></li><ul><li><div>Server can send executable code to client.</div></li><li><div>Enhances client-side functionality.</div></li><li><div>Example: Sending JavaScript code for UI enhancements.</div></li></ul></ol><div><br/></div><div style="margin-bottom:16px;"><br/></div></en-note>      ]]>
    </content>
  </note>
</en-export>
